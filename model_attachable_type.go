/*
Firefly III API v2.0.4

This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2023-06-11T09:14:35+00:00 

API version: 2.0.4
Contact: james@firefly-iii.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// AttachableType The object class to which the attachment must be linked.
type AttachableType string

// List of AttachableType
const (
	ACCOUNT AttachableType = "Account"
	BUDGET AttachableType = "Budget"
	BILL AttachableType = "Bill"
	TRANSACTION_JOURNAL AttachableType = "TransactionJournal"
	PIGGY_BANK AttachableType = "PiggyBank"
	TAG AttachableType = "Tag"
)

// All allowed values of AttachableType enum
var AllowedAttachableTypeEnumValues = []AttachableType{
	"Account",
	"Budget",
	"Bill",
	"TransactionJournal",
	"PiggyBank",
	"Tag",
}

func (v *AttachableType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := AttachableType(value)
	for _, existing := range AllowedAttachableTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid AttachableType", value)
}

// NewAttachableTypeFromValue returns a pointer to a valid AttachableType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewAttachableTypeFromValue(v string) (*AttachableType, error) {
	ev := AttachableType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for AttachableType: valid values are %v", v, AllowedAttachableTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v AttachableType) IsValid() bool {
	for _, existing := range AllowedAttachableTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to AttachableType value
func (v AttachableType) Ptr() *AttachableType {
	return &v
}

type NullableAttachableType struct {
	value *AttachableType
	isSet bool
}

func (v NullableAttachableType) Get() *AttachableType {
	return v.value
}

func (v *NullableAttachableType) Set(val *AttachableType) {
	v.value = val
	v.isSet = true
}

func (v NullableAttachableType) IsSet() bool {
	return v.isSet
}

func (v *NullableAttachableType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableAttachableType(val *AttachableType) *NullableAttachableType {
	return &NullableAttachableType{value: val, isSet: true}
}

func (v NullableAttachableType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableAttachableType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

